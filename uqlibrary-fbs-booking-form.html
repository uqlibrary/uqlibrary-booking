<link rel="import" href="../uqlibrary-elements/0.5.4/lib/vulcanized.html">

<!--
Element providing a form for booking a room.

##### Example

    <uqlibrary-fbs-booking-form></uqlibrary-fbs-booking-form>

    <script>
      (function () {

        window.addEventListener('polymer-ready', function() {

          var bookingForm = document.querySelector('uqlibrary-fbs-booking-form');
          bookingForm.setData({});

        });

      }());
    </script>

@element uqlibrary-fbs-booking-form
@blurb Element providing a FBS booking form
@status alpha
@homepage https://github.com/uqlibrary/uqlibrary-fbs-booking-form
-->

<polymer-element name="uqlibrary-fbs-booking-form" attributes="roomDetails">

<template>
  <link rel="stylesheet" href="../uqlibrary-elements/resources/theme/element.css">

  <div class="body-footer-container">

  <div class="image-header" style="background-image: url('https://app.library.uq.edu.au/assets/images/uq-buildings/{{ roomDetails.imageLarge }}')">

    <div class="title-container">
      <div class="title inverse">{{ roomDetails.title }}</div>
      <div class="subhead inverse">{{roomDetails | formatLocation }}</div>
    </div>

  </div>

  <p class="text-container body1">{{ roomDetails.notes }}
    <a class="icon" hidden?="{{!roomDetails.url}}" href="{{roomDetails.url}}" target="_blank">
      <core-icon icon="file-map"></core-icon>
    </a>
  </p>

  <uqlibrary-date-selector id="dateSelector" searchDate="{{ searchDate }}"
                           searchDuration="{{ searchDuration }}"
                           maxBookingDate="{{ maxBookingDate }}"
                           bookingTimeslots = "{{ bookingTimeslots }}"
                           maxBookingLength="{{ roomDetails.maxtime / roomDetails.time_span }}">
  </uqlibrary-date-selector>

  <p class="text-container caption">Maximum booking duration is {{ roomDetails.maxtime }} min, minimum booking duration is {{ roomDetails.mintime }} min</p>
  <p class="text-container caption">
    <span class="hint-box selected"></span> - your current selection
    <span class="hint-box available"></span> - available time slot
    <span class="hint-box unavailable"></span> - unavailable time slot
  </p>


  <uqlibrary-persistent-footer id="persistentFooter"></uqlibrary-persistent-footer>
  <paper-toast id="infoToast" flex></paper-toast>

  </div>

  <uqlibrary-api-facilities-booking id="createBookingRequest" on-uqlibrary-api-facilities-booking-executed="{{ createBookingComplete }}"></uqlibrary-api-facilities-booking>

</template>

<script>
(function() {
  Polymer('uqlibrary-fbs-booking-form', {
    /** Fired when booking was successfully created
     *
     * @event booking-created
     *
     */
    createBookingComplete : function(event){
      if (event.detail.response) {
        //display error returned by the server
        this.showInfoToast("Error creating a booking: " + event.detail.responseText);

      } else {
        //if booking is successful, fire event to indicate booking is done and move on to other page
        this.fire('booking-created');
      }
    },

    /** Fired when search date was changed on the booking form
     *
     * @event booking-date-changed
     *
     */
    searchDateChanged : function (oldValue, newValue) {
      if (this.searchDate.toDateString() != moment(this.roomDetails.available_from, "X").toDate().toDateString()) {
        this.fire('booking-date-changed', { searchDate: this.searchDate });
      }
    },

    created: function () {
      this.roomDetails = {};
      this.bookingDetails = {};
      this.searchDate = new Date();
      this.searchDuration = 90;
      this.maxBookingDate = new Date();
      this.bookingTimeslots = [];
    },

    ready: function () {
      this.addEventListener('submit-form', this.createRoomBooking);

      this.$.persistentFooter.actionButtons = [{title: 'Save booking', id: 'createRoomBooking', class:'colored'}];

      this.addEventListener('uqlibrary-persistent-footer-action-button-clicked', function(e) {
        if(e.detail.button && e.detail.button.id == 'createRoomBooking') {
          this.createRoomBooking();
        }
      });

    },

    /** The `setData` method expects data for display in booking form, eg
     * {
     *    roomDetails - room details with availability details
     *    bookingDetails - user's booking details for editing
     *    searchDate - current search date (defaults to bookingDetails date if it's specified)
     *    maxBookingDate - max date to display
     *    searchDuration - booking duration value in minutes (defaults to bookingDetails date if it's specified)
     * }
     *
     * @method setData
     *
     */
    setData: function(args) {
      if (args && args.roomDetails)
        this.roomDetails = args.roomDetails;

      if (args && args.bookingDetails) {
        this.bookingDetails = args.bookingDetails;
        this.searchDate = this.bookingDetails.startDate;
        this.searchDuration = (this.bookingDetails.endDate.getTime() - this.bookingDetails.startDate.getTime()) / (60*1000);
      } else {
        this.bookingDetails = null;
      }

      if (args && args.searchDate)
        this.searchDate = args.searchDate;

      if (args && args.searchDuration)
        this.searchDuration = args.searchDuration;

      if (args && args.maxBookingDate)
        this.maxBookingDate = args.maxBookingDate;

      this.bookingTimeslots = this.createTimeslots();
      this.selectTimeslots();

      this.$.dateSelector.bookingTimeslots = this.bookingTimeslots;
    },

    showInfoToast: function(text) {
      this.$.infoToast.text = text;
      this.$.infoToast.show();
    },

    validateSelection : function(selectedTimeslots) {
      var validation = {
        valid : true,
        message: ''
      };

      if (selectedTimeslots.length == 0) {
        validation.valid = false;
        validation.message = "Please, make a valid selection.";
      } else if (selectedTimeslots.length > this.maxtime / this.roomDetails.time_span) {
        validation.valid = false;
        validation.message = "Current selection exceeds maximum booking duration. Please, make a valid selection.";
      }
      else if (!selectedTimeslots.every(function(element, index) {
                return !(index < selectedTimeslots.length - 1 && element.endTime.valueOf() !== selectedTimeslots[index+1].startTime.valueOf());
              })) {
        validation.valid = false;
        validation.message = "Current selection is not available. Please, make another selection.";
      }

      return validation;
    },

    createRoomBooking : function () {
      // get currently selected elements
      var selectedTimeslots = this.bookingTimeslots.filter(function(item) { return item.selected; });
      var validation = this.validateSelection(selectedTimeslots);

      if (!validation.valid){
        this.showInfoToast(validation.message);
      } else {

        var midnight = new Date(selectedTimeslots[0].startTime.getFullYear(), selectedTimeslots[0].startTime.getMonth(), selectedTimeslots[0].startTime.getDate(), 0, 0, 0);
        var startTime = (selectedTimeslots[0].startTime - midnight) / (1000 * 60);
        var endTime = (selectedTimeslots[selectedTimeslots.length-1].endTime - midnight) / (1000 * 60);

        var newBooking = { booking : {
            machid: this.roomDetails.id,
            scheduleid: this.roomDetails.scheduleid,
            date: moment(selectedTimeslots[0].startTime).format("MM/DD/YYYY"),
            starttime: startTime,
            endtime: endTime
          }
        };

        if (this.bookingDetails && this.bookingDetails.id) {
          newBooking.booking.resid = this.bookingDetails.id;
        }

        this.$.createBookingRequest.post(newBooking);
      }
    },

    formatLocation : function (roomDetails) {
      var location = [];

      if (roomDetails.location)
        location.push(roomDetails.location);

      if (roomDetails.building)
        location.push(roomDetails.building);

      if (roomDetails)
        location.push(roomDetails.campus);

      return location.join(", ");
    },

    selectTimeslots : function() {

      //for booking editing, only set time on the date of the booking
      if (this.bookingDetails && this.bookingDetails.startDate) {
        //search duration is always the existing booking duration
        this.searchDuration = (this.bookingDetails.endDate.getTime() - this.bookingDetails.startDate.getTime()) / (60 * 1000);

        var bookingStartDateTest = new Date (this.bookingDetails.startDate);
        var searchDateTest = new Date(this.searchDate);

        if (searchDateTest.setHours(0,0,0,0) !== bookingStartDateTest.setHours(0,0,0,0))
          return;
      }

      var duration = parseInt(Math.min(this.roomDetails.maxtime, this.searchDuration)/this.roomDetails.time_span);
      var remainingDuration = duration;
      var searchDate = this.searchDate;

      this.bookingTimeslots.every(function(element, index) {

        if (element.selectable
                && ((searchDate >= element.startTime && searchDate < element.endTime) || remainingDuration < duration)) {
          element.selected = true;
          remainingDuration--;
        }

        //cannot break selection if there's an unavailable time slot
        return remainingDuration === duration
        || (remainingDuration > 0 && remainingDuration < duration && element.selectable);
      });
    },

    createTimeslots : function() {
      var that = this;

      var openingHours = moment(this.roomDetails.available_from, "X");
      var closingHours = moment(this.roomDetails.available_to, "X");
      var workingTimeslots = (closingHours - openingHours) / this.roomDetails.time_span / 60 / 1000;

      var currentDate = moment(new Date(openingHours.toDate()));
      var timeslots = [];

      for (var index = 0; index < workingTimeslots; index++){
        var timeslotStartTime = new Date(currentDate.toDate());
        var timeslotEndTime = new Date(currentDate.add(this.roomDetails.time_span, "m").toDate());

        var selectable = this.roomDetails.bookings.every(function(element, index, array){
          var bookingStartTime = moment(element.from, "X");
          var bookingEndTime = moment(element.to, "X");

          //timeslot is selectable if it belongs to a current booking in editing form
          if (that.bookingDetails && that.bookingDetails.startDate &&
                  timeslotStartTime.getTime() >= that.bookingDetails.startDate.getTime() &&
                  timeslotEndTime.getTime() <= that.bookingDetails.endDate.getTime()) {
            return true;
          }

          //timeslot does not overlap with existing booking
          if (bookingStartTime >= timeslotEndTime || bookingEndTime <= timeslotStartTime)
            return true;

          //timeslot overlaps with existing booking
          if ((timeslotStartTime >= bookingStartTime && timeslotEndTime <= bookingEndTime)
                  || (timeslotStartTime <= bookingStartTime && timeslotEndTime > bookingStartTime && timeslotEndTime < bookingEndTime)
                  || (timeslotStartTime > bookingStartTime && timeslotStartTime < bookingEndTime && timeslotEndTime >= bookingEndTime))
          {
            return false;
          }
        });

        timeslots.push(
                {
                  startTime: timeslotStartTime,
                  endTime: timeslotEndTime,
                  selected: false,
                  selectable: selectable
                });
      }

      return timeslots;
    }

  });
})();
</script>

</polymer-element>
